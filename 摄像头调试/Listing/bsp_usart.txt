; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o..\..\output\bsp_usart.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\bsp_usart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\GeneralTim -IF:\单片机\智能农装\机械摄像头完全体\Project\RVMDK（uv5）\RTE -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -ID:\Keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=515 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\bsp_usart.crf ..\..\User\usart\bsp_usart.c]
                          THUMB

                          AREA ||i.USART_Config||, CODE, READONLY, ALIGN=2

                  USART_Config PROC
;;;25       */
;;;26     void USART_Config(void)
000000  b500              PUSH     {lr}
;;;27     {
000002  b085              SUB      sp,sp,#0x14
;;;28     	GPIO_InitTypeDef GPIO_InitStructure;
;;;29     	USART_InitTypeDef USART_InitStructure;
;;;30     
;;;31     	// 打开串口GPIO的时钟
;;;32     	DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);
000004  2101              MOVS     r1,#1
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;33     	
;;;34     	// 打开串口外设的时钟
;;;35     	DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;36     
;;;37     	// 将USART Tx的GPIO配置为推挽复用模式
;;;38     	GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;
000014  f44f7000          MOV      r0,#0x200
000018  f8ad0010          STRH     r0,[sp,#0x10]
;;;39     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001c  2018              MOVS     r0,#0x18
00001e  f88d0013          STRB     r0,[sp,#0x13]
;;;40     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000022  2003              MOVS     r0,#3
000024  f88d0012          STRB     r0,[sp,#0x12]
;;;41     	GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStructure);
000028  a904              ADD      r1,sp,#0x10
00002a  4813              LDR      r0,|L1.120|
00002c  f7fffffe          BL       GPIO_Init
;;;42     
;;;43       // 将USART Rx的GPIO配置为浮空输入模式
;;;44     	GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;
000030  f44f6080          MOV      r0,#0x400
000034  f8ad0010          STRH     r0,[sp,#0x10]
;;;45     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000038  2004              MOVS     r0,#4
00003a  f88d0013          STRB     r0,[sp,#0x13]
;;;46     	GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &GPIO_InitStructure);
00003e  a904              ADD      r1,sp,#0x10
000040  480d              LDR      r0,|L1.120|
000042  f7fffffe          BL       GPIO_Init
;;;47     	
;;;48     	// 配置串口的工作参数
;;;49     	// 配置波特率
;;;50     	USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;
000046  f44f30e1          MOV      r0,#0x1c200
00004a  9000              STR      r0,[sp,#0]
;;;51     	// 配置 针数据字长
;;;52     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00004c  2000              MOVS     r0,#0
00004e  f8ad0004          STRH     r0,[sp,#4]
;;;53     	// 配置停止位
;;;54     	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000052  f8ad0006          STRH     r0,[sp,#6]
;;;55     	// 配置校验位
;;;56     	USART_InitStructure.USART_Parity = USART_Parity_No ;
000056  f8ad0008          STRH     r0,[sp,#8]
;;;57     	// 配置硬件流控制
;;;58     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00005a  f8ad000c          STRH     r0,[sp,#0xc]
;;;59     	// 配置工作模式，收发一起
;;;60     	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00005e  200c              MOVS     r0,#0xc
000060  f8ad000a          STRH     r0,[sp,#0xa]
;;;61     	// 完成串口的初始化配置
;;;62     	USART_Init(DEBUG_USARTx, &USART_InitStructure);
000064  4669              MOV      r1,sp
000066  4805              LDR      r0,|L1.124|
000068  f7fffffe          BL       USART_Init
;;;63     
;;;64     	// 使能串口
;;;65     	USART_Cmd(DEBUG_USARTx, ENABLE);	    
00006c  2101              MOVS     r1,#1
00006e  4803              LDR      r0,|L1.124|
000070  f7fffffe          BL       USART_Cmd
;;;66     }
000074  b005              ADD      sp,sp,#0x14
000076  bd00              POP      {pc}
;;;67     
                          ENDP

                  |L1.120|
                          DCD      0x40010800
                  |L1.124|
                          DCD      0x40013800

                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=2

                  fgetc PROC
;;;81     ///重定向c库函数scanf到串口，重写向后可使用scanf、getchar等函数
;;;82     int fgetc(FILE *f)
000000  b510              PUSH     {r4,lr}
;;;83     {
000002  4604              MOV      r4,r0
;;;84     		/* 等待串口输入数据 */
;;;85     		while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_RXNE) == RESET);
000004  bf00              NOP      
                  |L2.6|
000006  2120              MOVS     r1,#0x20
000008  4804              LDR      r0,|L2.28|
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L2.6|
;;;86     
;;;87     		return (int)USART_ReceiveData(DEBUG_USARTx);
000012  4802              LDR      r0,|L2.28|
000014  f7fffffe          BL       USART_ReceiveData
;;;88     }
000018  bd10              POP      {r4,pc}
;;;89     
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x40013800

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;69     ///重定向c库函数printf到串口，重定向后可使用printf函数
;;;70     int fputc(int ch, FILE *f)
000000  b570              PUSH     {r4-r6,lr}
;;;71     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;72     		/* 发送一个字节数据到串口 */
;;;73     		USART_SendData(DEBUG_USARTx, (uint8_t) ch);
000006  b2e1              UXTB     r1,r4
000008  4805              LDR      r0,|L3.32|
00000a  f7fffffe          BL       USART_SendData
;;;74     		
;;;75     		/* 等待发送完毕 */
;;;76     		while (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) == RESET);		
00000e  bf00              NOP      
                  |L3.16|
000010  2180              MOVS     r1,#0x80
000012  4803              LDR      r0,|L3.32|
000014  f7fffffe          BL       USART_GetFlagStatus
000018  2800              CMP      r0,#0
00001a  d0f9              BEQ      |L3.16|
;;;77     	
;;;78     		return (ch);
00001c  4620              MOV      r0,r4
;;;79     }
00001e  bd70              POP      {r4-r6,pc}
;;;80     
                          ENDP

                  |L3.32|
                          DCD      0x40013800
